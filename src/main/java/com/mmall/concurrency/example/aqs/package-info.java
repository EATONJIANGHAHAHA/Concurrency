package com.mmall.concurrency.example.aqs;

/*
AbstractQueuedSynchronizer - AQS,内部的实现由一个双向列表, 负责维护线程的执行顺序,并且可能存在多个conditionQueue, 这是一个单向列表,
只有当程序中需要使用到condition的时候才会被建立.
1. Node实现FIFO队列, 可以用于构建锁或者其他同步装置的基础框架.
2. 利用了一个int表示了状态, 在大多数同步装置里面这个变量表示了: 0 = 没有线程获取了锁, 1 = 已经有线程获取了锁, > 1 = 存入的锁的数量.
3. 使用的方法是继承
4. 子类需要通过继承并实现他的方法管理其状态, acquire() 和 release() 操纵状态.
5. 可以同时实现排它锁和共享锁模式 (独占, 共享)

CountDownLatch组件:并发控制,这个组件允许阻塞调用它的线程,可以使一个线程或多个线程阻塞,在其他线程完成任务后再继续执行这个线程的后续工作.
它的计数器不可以被重置.
它的使用主要是由两个方法组成:

Semaphor组件: 信号量, 并发控制, 可以控制并发访问的线程个数. 常用于仅能提供有限访问的资源, 比如数据库链接数
1. 构造器中传入同时访问的线程数

CyclicBarrier: 循环屏障, 允许一组线程相互等待, 通过它可以完成多个线程相互等待, 只有当多个线程满足条件才继续执行等待的线程. 它与countdownlatch很相似,
内部也维护了一个计数器, 但是这个计数器是可以重置的. 计数器是从0开始向上递增, 直到递增到计数器的目标值后继续执行等待线程.
多用于多线程计算数据, 然后合并计算结果.

锁:
synchronize关键字修饰的锁, 还有就是Lock借口实现的锁.
ReentrantLock: 可重入锁,自行实现, 使用没有synchronized方便, 有时可能忘记释放锁.可以选择公平锁(先等待的线程先获得锁)还是非公平锁,
并且提供了condition类,可以实现分组唤醒线程, 提供了可以终端等待锁的机制,
synchronized: JVM实现的,源码不可查,在JDK]5.0之前,它的性能是非常底下的, 官方对现版本已经进行了优化,非公平锁, 只能唤醒一个或者全部线程

 */