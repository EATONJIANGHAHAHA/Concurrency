package com.mmall.concurrency.example.ThreadSafty;

/*
 * 线程安全的定义:当多个线程访问某个类时,不管运行时采用何种调度方式或者这些进程将如何交替执行,并且在主调代码中不需要任何额外的同步或协同,
 * 这个类都能表现出正确的行为,那么就称这个类是线程安全的.
 *
 * 原子性:提供了互斥访问,同一时刻只能有一个线程来对他进行操作
 * 可见性:一个线程对主内存的修改可以及时地被其他线程观察到
 * 有序性:一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序．
 *
 * 有序性的具体内容: Java内存模型中,允许编译器核处理器对指令进行小红心排序,但是排序过程不会影响到单线程程序的执行,却会影响到多线程并发执行的正确性.
 * volatile, synchronized, lock
 * 先行发生原则:
 * 1:程序次序规则：　一个线程内，按照代码顺序，书写在前面的操作线性发生于书写在后面的操作（在单个线程中看起来是有序的）ＪＶＭ会对没有变量依赖性的程序
 * 代码进行指令的重新排序，一直与编程人员在外部观察起来程序依然是有序的．因此，无法保证在多线程中的执行正确性．
 * ２:锁定规则： 一个unlock操作现行法生育后面对同一个锁的lock操作, 无论在单线程中还是多线程中, 必须先对指定锁进行解锁操作,才能对这个变量执行
 * 枷锁操作.
 * 3:volatile变量规则:对一个变量的写操作线性发生于面对这个变量的读操作.
 * 4:传递规则:如果操作A线性发生于操作B,而操作B先行有线性发生于操作C, 则操作A线性发生于操作C, 体现了线性发生原则具备传递性
 * 5:线程启动原则:Thread对象的start()方法线性发生于此线程的每一个动作.
 * 6:线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生.
 * 7:线程终结规则:线程中所有的操作都先行发生于线程的终止检测,我们可以通过thread.join()方法结束,
 * thread.isAlive()的返回值手段检测到线程已经中止执行.
 * 8:对象终结规则: 一个对象的初始化完成,线性发生于他的finalize()方法的开始.
 *
 * 如果两个操作的执行次序无法从先行发生原则推导出来,则不能保证两个操作执行次序的有序性,虚拟机可以随意的对她们进行重排序.
 */